###############################################PROGRAM#########################################

execute[[Program: program -> varDefinition* funcDefinition*]] =
		< ' * Global variables:>
		varDefinition.forEach(vd -> execute[[vd]]())
		funcDefinition*.forEach(fd -> execute[[fd]]())

###################################READ#####################################

execute[[Read: st -> exp]] = 
	address[[exp]]
	<in> exp.type.suffix()
	<store> exp.type.suffix()
	
##################################WRITE#####################################

execute[[Write: st -> exp]] = 
	value[[exp]]
	<out> exp.type.suffix()	

################################CONSTANTS###################################

value[[CharLiteral: exp -> CHAR_CONSTANT]] = 
	<push>exp.type.suffix()< >(int)exp.value
	
value[[IntLiteral: exp -> INT_CONSTANT]] = 
	<push>exp.type.suffix()< >exp.value
	
value[[DoubleLiteral: exp -> DOUBLE_CONSTANT]] = 
	<push>exp.type.suffix()< >exp.value
	
#############################VARIABLE####################################

address[[Variable: exp -> ID]] = 
	if(exp.definition.scope==0)
		<pusha > exp.definition.offset
	else
		<push bp>
		<pushi exp.definition.offset>
		<addi>
		
value[[Variable: exp -> ID]] =
	address[[exp]]
	<load> exp.type.suffix()
	
#############################ARITHMETIC OPERATION#########################

value[[Arithmetic: exp1 -> exp2 (+|-|*|/) exp3]] = 
	value[[exp2]]
	exp2.type.convertTo(exp1.type)
	value[[exp3]]
	exp3.type.convertTo(exp1.type)
	switch(exp1.operator) {
		case "+": <add> exp1.type.suffix() break;
		case "-": <add> exp1.type.suffix() break;
		case "*": <add> exp1.type.suffix() break;
		case "/": <add> exp1.type.suffix() break;
	}
		
#############################COMPARISON OPERATION######################### 							PREGUNTAR SI HACE FALTA CONVERT

value[[Comparisson: exp1 -> exp2 (>|<|>=|<=|!=|==) exp3]] = 
	value[[exp2]]
	exp2.type.convertTo(exp1.type)
	value[[exp3]]
	exp3.type.convertTo(exp1.type)
	switch(exp1.operator) {
		case ">": <gt> exp1.type.suffix() break;
		case "<": <lt> exp1.type.suffix() break;
		case ">=": <ge> exp1.type.suffix() break;
		case "<=": <le> exp1.type.suffix() break;
		case "==": <eq> exp1.type.suffix() break;
		case "!=": <ne> exp1.type.suffix() break;
	}
	
#############################LOGICAL OPERATION#########################								PREGUNTAR SI HACE FALTA CONVERT			

value[[Logical: exp1 -> exp2 (&&|||) exp3]] = 
	value[[exp2]]
	exp2.type.convertTo(exp1.type)
	value[[exp3]]
	exp3.type.convertTo(exp1.type)
	switch(exp1.operator) {
		case "&&": <and> break;
		case "||": <or>  break;
	}
	
#############################ASSIGNMENT####################################

execute[[Assignment: st -> exp1 exp2]] = 
	address[[exp1]]
	value[[exp2]]
	<load>exp1.type.suffix()
	
####################################CAST##################################

value[[Cast: exp1 -> type exp2]] = 
	value[[exp2]]
	exp2.type.convertTo(exp1.type)
	
#####################################VAR DEFINITIONS######################

execute[[VarDefinition: varDefinition -> type ID]] = 
	<' * > type.toString() ID <( offset > varDefinition.offset <)>
	
#####################################FUNC DEFINITIONS######################

execute[[FuncDefinition: funcDefinition -> type ID varDefinition* statement*]] = 
		ID<:>
		int byteParams = execute[[type]]
		<' * Local variables:>
		varDefinition*.foreach(vd -> execute[[vd]]())
		
		int bytesLocals = 0;
		if(varDefinition*.size()>0)
			bytesLocals = -varDefinition*.get(varDefinition*.size()-1).offset
		<enter > bytesLocals
		
		int bytesReturn = type.returnType.numberOfBytes();
		
        statement*.foreach(st -> execute[[st]](bytesLocals, bytesParams, bytesReturn))
		
		if(bytesReturn==0)
			<ret > bytesReturn, bytesLocals, bytesParams
		
		
execute [[FuncType : type1 -> type2 varDefinition*]] = 							PREGUNTAR CÃ“MO SE RETORNA ALGO
		int byteParams = 0;
		<' * Parameters:>
		varDefinition*.forEach(vd -> {
			execute[[vd]]()
			byteParams += vd.type.numberOfBytes();
		})

execute[[Return: statement -> expression]](int bytesLocals, int byteParams, int bytesReturn) = 
	value[[exp]]
	ret bytesReturn, bytesLocals, bytesParams
		



